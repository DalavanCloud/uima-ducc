# Declare which components to load into the jvm on process startup.
ducc.jms.provider=activemq

# ---------------------------------------------------
# ---------------------------------------------------
# Define the ActivemQ broker configuration. 
#    ducc.broker.protocol - Ddefine broker protocol. Should typically be 
#                           tcp. *** Dont specify : or // ***
# ducc.broker.hostname    - The name of the host where the broker is running.
# ducc.broker.port        - The broker's connection port
# ducc.broker.url.decoration - The broker *client* url decoration.
#        recoveryInterval=30000 - Specifies an interval between recovery attempts,
#                                 i.e when  a connection is being refreshed, 
#                                 in milliseconds
#        jms.useCompression=true - Compress message body
# ducc.broker.name        - the broker name - must match the actual broker name
#                           in the broker config.  THIS IS NOT THE BROKER HOSTNAME
#                           WHICH IS CONFIGURED IN ducc.broker.hostname.
# ducc.broker.jmx.port    - the Broker's jmx port
#
ducc.broker.protocol=tcp
ducc.broker.hostname=${ducc.head}
ducc.broker.port=61616
ducc.broker.url.decoration=wireFormat.maxInactivityDuration=0&jms.useCompression=true
ducc.broker.name=localhost
ducc.broker.jmx.port=1099

# ActiveMQ Auto-management configuration
#    docc.broker.automanage    - if true, DUCC will start and stop the broker as needed.  
#                                Otherwise, the installation is responsible for
#                                manageing ActiveMQ
#    ducc.broker.memor.options - If automanaged, the memory configuration passed to the JVM
#    ducc.broker.configuration - If automanaged, the location of the ActiveMQ broker configuration
#    ducc.broker.home          - If automanaged, the location of the ActiveMQ installation
#    ducc.broker.server.url.decoration - If automanaged, the broker URL decoration
#
ducc.broker.automanage = true
ducc.broker.memory.options = -Xmx2G
ducc.broker.configuration = conf/activemq-nojournal5.xml
ducc.broker.home = ${DUCC_HOME}/activemq
ducc.broker.server.url.decoration = transport.soWriteTimeout=45000

# To enable tracing of RM messages arriving in OR and NodeMetrics arriving in WS.
#ducc.transport.trace = orchestrator:RmStateDuccEvent webserver:NodeMetricsUpdateDuccEvent

ducc.cluster.name=Apache UIMA-DUCC

#ducc.authentication.implementer=an.authentication.Manager

# ducc.runmode=Test

ducc.locale.language=en
ducc.locale.country=us

# Specify a minimum amount of free swap space available on a node.
# If an agent detects free swap space dipping below the value defined
# below, it will find the fattest (in terms of memory) process in its
# inventory and kill it. The value of the parameter below is expressed
# in Megabytes.
# Initially disabled by setting the threshold at 0.
ducc.node.min.swap.threshold=0

# administrative endpoint for all ducc components
ducc.admin.endpoint=ducc.admin.channel
# endpoint type choices[vm,queue,topic]
ducc.admin.endpoint.type=topic

# jmx port number for Ducc process. Each Ducc process will attempt
# to use this port for its JMX Connector. If the port is not available
# port+1 will be used until an available port is found.
ducc.jmx.port=2099

ducc.agent.jvm.args        = -Xmx100M
ducc.orchestrator.jvm.args = -Xmx1G
ducc.rm.jvm.args           = -Xmx1G
ducc.pm.jvm.args           = -Xmx1G
ducc.sm.jvm.args           = -Xmx1G
ducc.ws.jvm.args           = -Xmx8G

# ========== CLI Configuration block ==========
#ducc.submit.threads.limit=200
#ducc.submit.driver.jvm.args=-XX:+HeapDumpOnOutOfMemoryError
#ducc.submit.process.jvm.args=-XX:+HeapDumpOnOutOfMemoryError
# No timeout
ducc.cli.httpclient.sotimeout=0
#------------------------------------------------------------------------------
#	off,  // CLI submit and cancel signature enforcement disabled
#	on,   // CLI submit and cancel signature enforcement enabled (default)
ducc.signature.required=on
#------------------------------------------------------------------------------
#	on  // CLI submit backward compatibility for: classpath, environment, jvmargs (default)
#	off // CLI submit NO backward compatibility
ducc.submit.beta=on
#------------------------------------------------------------------------------

# ========== Web Server Configuration block ==========
ducc.ws.configuration.class=org.apache.uima.ducc.ws.config.WebServerConfiguration
# Optionally configure the webserver node
#ducc.ws.node = my.node.com
# Optionally configure the webserver IP address
#ducc.ws.ipaddress = 192.168.3.77
# Optionally configure the webserver IP port for HTTP requests, default is 42133
ducc.ws.port = 42133
# Optionally configure the webserver IP port for HTTPS requests, default is 42155
ducc.ws.port.ssl = 42155
# Optionally configure the webserver ssl pw for  HTTPS requests, default is quackquack
ducc.ws.port.ssl.pw = quackquack
# Optionally configure the webserver login session timeout, in minutes, default is 60
ducc.ws.session.minutes = 60
# Optionally configure the webserver job automatic cancel timeout, default is 10. To disable feature specify 0.
#   Employed when user specifies --wait_for_completion flag on job submission, in which case the job monitor
#   program must visit http://<host>:<port>/ducc-servlet/proxy-job-status?id=<job-id> within this expiry time
#   else the job will be automatically canceled (unless feature disabled) by the webserver acting as the 
#   administrator ducc (which must be specified in the ducc.administrators file).
ducc.ws.automatic.cancel.minutes = 5
# Optionally configure the webserver max history entries for each of Jobs/Reservations/Services
ducc.ws.max.history.entries = 4096
# Specify the ducc jsp comp dir
ducc.ws.jsp.compilation.directory = /tmp/ducc/jsp
# <for Apache only>
#uncomment this line and set pw for login to webserver, otherwise no pw required to login.
#ducc.ws.authentication.pw = ducksoup
# </for Apache only>
# ========== Web Server Configuration block ==========

# ========== Job Driver Configuration block ==========
ducc.jd.configuration.class=org.apache.uima.ducc.jd.config.JobDriverConfiguration
ducc.jd.state.update.endpoint=ducc.jd.state
# endpoint type choices[vm,queue,topic]
ducc.jd.state.update.endpoint.type=topic
ducc.jd.state.publish.rate=15000
ducc.jd.queue.prefix=ducc.jd.queue.
ducc.jd.host.class=JobDriver
ducc.jd.host.description=Job Driver
ducc.jd.host.memory.size=1GB
ducc.jd.host.number.of.machines=1
ducc.jd.host.user=System
# Base size of dram quantum for JD in Mb
ducc.jd.share.quantum = 400
# ========== Job Driver Configuration block ==========


# ========== Service Manager Configuration block ========== 
ducc.sm.configuration.class=org.apache.uima.ducc.sm.config.ServiceManagerConfiguration
ducc.sm.state.update.endpoint=ducc.sm.state
ducc.sm.state.update.endpoint.type=topic
ducc.sm.meta.ping.rate = 60000
ducc.sm.meta.ping.stability =  10
ducc.sm.meta.ping.timeout =  5000
ducc.sm.instance.falure.max = 5
ducc.sm.http.port=19989
ducc.sm.http.node=${ducc.head}
ducc.sm.default.linger=300000
# === END == Service Manager Configuration block ========== 

# ========== Orchestrator Configuration block ==========
ducc.orchestrator.configuration.class=org.apache.uima.ducc.orchestrator.config.OrchestratorConfiguration
#ducc.orchestrator.checkpoint=off
ducc.orchestrator.checkpoint=on
#------------------------------------------------------------------------------
#	cold, // Recover: All is lost					JD host: employ new
#	warm, // Recover: Reservations only (default) 	JD host: employ new
#	hot , // Recover: Reservations and Jobs, 		JD host: employ current
ducc.orchestrator.start.type=warm
#------------------------------------------------------------------------------
#ducc.orchestrator.retain.completed.hours=200
ducc.orchestrator.request.endpoint=ducc.orchestrator.request?requestTimeout=180000
# endpoint type choices[vm,queue,topic]
ducc.orchestrator.request.endpoint.type=queue
#------------------------------------------------------------------------------
ducc.orchestrator.state.update.endpoint=ducc.orchestrator.state
# endpoint type choices[vm,queue,topic]
ducc.orchestrator.state.update.endpoint.type=topic
ducc.orchestrator.state.publish.rate=15000
#------------------------------------------------------------------------------
ducc.orchestrator.abbreviated.state.update.endpoint=ducc.orchestrator.abbreviated.state
# endpoint type choices[vm,queue,topic]
ducc.orchestrator.abbreviated.state.update.endpoint.type=topic
ducc.orchestrator.abbreviated.state.publish.rate=15000
#------------------------------------------------------------------------------
ducc.orchestrator.maintenance.rate=60000
#------------------------------------------------------------------------------
#ducc.orchestrator.job.factory.classpath.order=ducc-before-user
ducc.orchestrator.job.factory.classpath.order=user-before-ducc
#------------------------------------------------------------------------------
# orchestrator's jetty http port
ducc.orchestrator.http.port=19988
# !!!!!!!! Node where OR is running. This is needed by CLI
# to compose a URL to access OR jetty server
ducc.orchestrator.node=${ducc.head}
# ========== Orchestrator Configuration block ==========

# Resource Manager Configuration block
ducc.rm.configuration.class=org.apache.uima.ducc.rm.config.ResourceManagerConfiguration
# Queue name for broadcast RM state
ducc.rm.state.update.endpoint=ducc.rm.state
# If enabled, RM tries to start as soon as it recoveres state from an OR publication,
# instread of waiting for init.stability for nodes to check in. 
ducc.rm.state.update.endpoint.type=topic
# This is the scheduling epoch in milliseconds. We publish at the end of each epoch.
ducc.rm.fast.recovery = false
# endpoint type choices[vm,queue,topic]
ducc.rm.state.publish.rate = 60000
# Base size of dram quantum in Gb
ducc.rm.share.quantum = 1
# Implementation class for actual scheduling algorithm
ducc.rm.scheduler = org.apache.uima.ducc.rm.scheduler.NodepoolScheduler
# File defining thescheduler classes - found in DUCC_HOME/resources
ducc.rm.class.definitions = ducc.classes
# default number of questions if not specified in job
ducc.rm.default.tasks = 10
# default memory, in GB, if not specified in job
ducc.rm.default.memory = 15
#default number of threads, if not specified in job
ducc.rm.default.threads = 4
# number of node metrics heartbeats to wait for before rm starts up
ducc.rm.init.stability = 2
# number of missed node metrics updates to consider node down
ducc.rm.node.stability = 5
# which policy to use when shrinking/evicting shares - alternatively, SHRINK_BY_MACHINE
ducc.rm.eviction.policy = SHRINK_BY_INVESTMENT
# max nodes to initially allocate until init is complete
ducc.rm.initialization.cap = 2
# When true, jobs expand not all at once after init, but a bit slower, doubling each epoch
# until max fair-share is set.  If false, jobs increase immediately to their fair share,
# at the cost of mass evictions.
ducc.rm.expand.by.doubling = true
# Predict when a job will end and avoid expanding if not needed
ducc.rm.prediction = true
# Add this fudge factor (milliseconds) to the expansion target when using prediction
ducc.rm.prediction.fudge = 120000
# If enabled, RM insures every job has a "foot in the door", some minimum number of processes, and if not
# attempts to find space for under-provisioned jobs by taking shares from "rich" jobs.  Note this may
# not always be possible if the cluster itseslf is under-provisioned for the load.
ducc.rm.defragmentation = true
# What is minimum number of processes for a job before we do defrag? If a job has less than this amount
# RM may attempt defragmentation to bring the processes up to this value.
ducc.rm.fragmentation.threshold = 2

# Agent Configuration block
ducc.agent.configuration.class=org.apache.uima.ducc.agent.config.AgentConfiguration
ducc.agent.request.endpoint=ducc.agent
# endpoint type choices[vm,queue,topic]
ducc.agent.request.endpoint.type=topic

# Endpoint where uima as service wrapper reports status
ducc.agent.managed.process.state.update.endpoint=ducc.managed.process.state.update
# endpoint type choices[vm,queue,topic,socket]
ducc.agent.managed.process.state.update.endpoint.type=socket
# endpoint parameters which are transport specific. For socket
# transport params are:
#  - transferExchange=true - include Camel Exchange wrapper in a message 
#  - synch=false - use socket transport for one-way messaging (no replies neeeded)
ducc.agent.managed.process.state.update.endpoint.params=transferExchange=true&sync=false

ducc.agent.node.metrics.publish.rate=60000
ducc.agent.node.metrics.endpoint=ducc.node.metrics
# endpoint type choices[vm,queue,topic]
ducc.agent.node.metrics.endpoint.type=topic
# Rate at which an agent publishes its process inventory
# The agent will only publish at this rate if there are
# changes since the last publish.
ducc.agent.node.inventory.publish.rate=10000
# If no changes in inventory, publish every 30 intervals defined by ducc.agent.node.inventory.publish.rate
ducc.agent.node.inventory.publish.rate.skip=30
ducc.agent.node.inventory.endpoint=ducc.node.inventory
# endpoint type choices[vm,queue,topic]
ducc.agent.node.inventory.endpoint.type=topic
ducc.agent.launcher.thread.pool.size=10
# enable/disable use of ducc_ling
ducc.agent.launcher.use.ducc_spawn=true
# specify location of ducc_ling in the filesystem
ducc.agent.launcher.ducc_spawn_path=${DUCC_HOME}/admin/ducc_ling
#ducc.agent.simulation.machine.config = resources/hw4.config
# Max amount of time (in millis) agent allows the process to stop before issuing kill -9
ducc.agent.launcher.process.stop.timeout=60000
# Max tim in millis allowed for AE initialization. Default 2 hours 7200000.                                                                 
ducc.agent.launcher.process.init.timeout=7200000
# exclude the following user ids while detecting rogue processes
ducc.agent.rogue.process.user.exclusion.filter=root,postfix,ntp,nobody,daemon,100
#exclude the following processes while detecting rogue processes
ducc.agent.rogue.process.exclusion.filter=sshd:,-bash,-sh,/bin/sh,/bin/bash,grep,ps
# Fudge Factor (in terms of percantage) that agent uses to multiply a share size when 
# determining if a JP exceeds its alloted memory, which is calculated as follows
# (fudge factor/100)*share size + share size. If this number exceeds JPs RSS, the agent
# kills the process.  
ducc.agent.share.size.fudge.factor=5
# Enable/Disable CGroup support. 
ducc.agent.launcher.cgroups.enable=false
# exclusion file to enable node based exclusion for cgroups and aps
# syntax:  <node>=cgroups,ap
# the above will exclude node from using cgroups and prevent deployment of APs
ducc.agent.exclusion.file=${DUCC_HOME}/resources/exclusion.nodes
#
# Uncomment the following line to support auto reaping of rogue processes by Ducc's Agent
# ducc.agent.rogue.process.reaper.script=${DUCC_HOME}/admin/ducc_reap_rogues.sh
#
# Process Manager Configuration block
ducc.pm.configuration.class=org.apache.uima.ducc.pm.config.ProcessManagerConfiguration
ducc.pm.request.endpoint=ducc.pm
# endpoint type choices[vm,queue,topic]
ducc.pm.request.endpoint.type=queue
#------------------------------------------------------------------------------
ducc.pm.state.update.endpoint=ducc.pm.state
# endpoint type choices[vm,queue,topic]
ducc.pm.state.update.endpoint.type=topic
ducc.pm.state.publish.rate=25000

# UIMA AS Managed Process Configuration block
ducc.uima-as.configuration.class=org.apache.uima.ducc.agent.deploy.uima.UimaAsServiceConfiguration
ducc.uima-as.endpoint=ducc.job.managed.service
# endpoint type choices[vm,queue,topic,socket]
ducc.uima-as.endpoint.type=socket
# endpoint parameters which are transport specific. For socket
# transport params are:
#  - transferExchange=true - include Camel Exchange wrapper in a message 
#  - synch=false - use socket transport for one-way messaging (no replies neeeded)
ducc.uima-as.endpoint.params=transferExchange=true&sync=false


ducc.uima-as.saxon.jar.path=file:${DUCC_HOME}/lib/saxon/saxon8.jar
ducc.uima-as.dd2spring.xsl.path=${DUCC_HOME}/resources/dd2spring.xsl
# custom Flow Controller to use for Ducc Job Processes
ducc.uima-as.flow-controller.specifier=DuccJobProcessFC



