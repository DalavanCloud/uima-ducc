#!/usr/bin/env python
# -----------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# -----------------------------------------------------------------------


import os
import sys
import time
import getopt

from ducc_util import DuccUtil
from ducc_base  import DuccProperties
from local_hooks import verify_slave_node
from local_hooks import verify_master_node
from local_hooks import verify_master_node
from ducc        import Ducc

class StartDucc(DuccUtil):

    def start_broker(self):
        
        broker_host = self.ducc_properties.get('ducc.broker.hostname')
        print 'broker host', broker_host
        lines = self.ssh(broker_host, True, "'", self.DUCC_HOME + '/admin/ducc.py', '-c', 'broker', "'")
        while 1:
            line = lines.readline().strip()
            if ( not line ):
                break
            #print '[] ' + line
            if ( line.startswith('PID') ):
                toks = line.split(' ')    # get the PID
                print "Broker on", broker_host, 'PID', toks[1]
                self.pids.put('broker@' + broker_host, toks[1])
                lines.close()
                break

        for i in range(0, 9):
            if ( self.is_amq_active() ):
                return
            print 'Waiting for broker', str(i)
            time.sleep(1)

    def start_component(self, ducc, component, or_parms, single_user):

        node = self.ducc_properties.get('ducc.head')
        com = component
        if ( com.find('@') >= 0 ):            
            com, node = com.split('@')

        if ( ((com == 'ws') or (com == 'viz')) and ( node == 'local' ) and ( self.webserver_node != 'localhost' )):
            if ( self.webserver_node != None ):
                node = self.webserver_node
                component = com + '@' + node

        if ((com in self.default_components) or ( com == 'agent')) :
            print node, 'Starting', com
        else:
            self.invalid('Unrecognized component', component)


        if ( or_parms == None ):
            or_parms = '--or_parms='
        else:
            or_parms = '--or_parms=' + or_parms

        if ( node == 'local' ):
            node = self.localhost

        if ( single_user ):
            lines = self.ssh(node, True, "'", self.DUCC_HOME + '/admin/ducc.py', '-c', com, '-s', '-b', or_parms, '-d', str(time.time()), '--nodup', "'")
        else:
            lines = self.ssh(node, True, "'", self.DUCC_HOME + '/admin/ducc.py', '-c', com, '-b', or_parms, '-d', str(time.time()), '--nodup', "'")

        # we'll capture anything that the python shell spews because it may be useful, and then drop the
        # pipe when we see a PID message
        while 1:
            line = lines.readline().strip()
            if ( not line ):
                break
            #print '[] ' + line
            if ( line.startswith('PID') ):
                toks = line.split(' ')    # get the PID
                print '     PID', toks[1]
                self.pids.put(com + '@' + node, toks[1])
                lines.close()
                break
            if ( line.startswith('WARN') ):
                print '    ', line
            
        if ( com in self.default_components ):           # tracks where the management processes are
            self.pids.put(com, com + '@' + node)

    def start_agents(self, nodelist, single_user):

        # print 'NODELIST', nodelist
        #counter = 1
        for host in nodelist:
            #print 'COUNTER', counter
            #counter = counter + 1
            
            spacer = '   '
            print host
            if (single_user):
                lines = self.ssh(host, True, "'", self.DUCC_HOME + '/admin/ducc.py', '-c' 'agent', '-s', '-b', '-d', str(time.time()), '--nodup', "'")
            else:
                lines = self.ssh(host, True, "'", self.DUCC_HOME + '/admin/ducc.py', '-c' 'agent', '-b', '-d', str(time.time()), '--nodup', "'")

            while 1:
                line = lines.readline().strip()
                #print '[l]' + line
                if ( line.startswith('PID') ):
                    toks = line.split(' ')
                    pid = toks[1]
                    self.pids.put('agent@' + host, pid)
                    lines.close()
                    print spacer, 'DUCC Agent started PID', pid
                    break

                if ( not line ):
                    break
                toks = line.split()
                # things that need checking:
                # 1. Connection refused
                # 2. "Add to keys" footprint message
                # 3. Connection hang
                # 4. - Passwordless not configured right
                # 5. - no ducc.py on the other side
                # 6. duccling not configured right on the other side
                # 7. there is already a process of the given type on the other side
                if ( not self.ssh_ok(host, line ) ):
                    break;
                
                if ( toks[0] == 'NOTOK' ):
                    print spacer, 'NOTOK Not started:', ' '.join(toks[1:])
                else:
                    print spacer, line

    def verify_required_directories(self):        
        for dir in ('history', 'state', 'logs'):
            d = self.DUCC_HOME + '/' + dir
            if ( not os.path.exists(d) ):
                print "Initializing", d
                os.mkdir(d)

    def usage(self, *msg):
        if ( msg[0] != None ):
            print ' '.join(msg)

        print "Usage:"
        print "   start_ducc [options]"
        print "        If no options are given, all DUCC processes are started, using the default"
        print "        nodelist, DUCC_HOME/resources/ducc.nodes.  This is the equivalemnt of"
        print ""
        print "        start_ducc -n $DUCC_HOME/resources/ducc.nodes -m"
        print ""
        print "Options:"
        print "   -n --nodelist nodefile"
        print "        Start agents on the nodes in the nodefile.  Multiple nodefiles may be specified:"
        print ""
        print "        start_ducc -n foo.nodes -n bar.nodes -n baz.nodes"
        print ""
        print "   -m --management"
        print "        Start the management processes (rm, sm, pm, webserver, orchestrator) on the local node."
        print ""
        print "   -s --singleuser"
        print "        Start ducc in 'single user mode'.  This bypasses some checking required for multi-user"
        print "        mode and not required for single-user mode."
        print ""
        print "   -c, --component component"
        print "        Start a specific DUCC component, optionally on a specific node.  If the component name"
        print "        is qualified with a nodename, the component is started on that node.  To qualify a"
        print "        component name with a destination node, use the notation component@nodename."
        print "        Multiple components may be specified:"
        print ""
        print "        start_ducc -c sm -c pm -c rm@f9n4 -c or@bluej22 -c agent@remote1 -c agent@remote2"
        print ""
        print "        Components include:"
        print "          rm - resource manager"
        print "          or - orchestrator"
        print "          pm - process manager"
        print "          sm - services manager"
        print "          ws - web server"
        print "          viz - visualization server"
        print "          agent - node agent"        
        print ""
        print "Examples:"
        print "   Start all DUCC processes, using custom nodelists:"
        print "       start_ducc -m -n foo.nodes -n bar.nodes"
        print ""
        print "   Start just managemnet processes:"
        print "       start_ducc -m"
        print ""
        print "   Start just agents on a specific set of nodes:"
        print "       start_ducc -n foo.nodes -n bar.nodes"
        print ""
        print "   Start the webserver on node 'bingle':"
        print "       start_ducc -c ws@bingle" 
        sys.exit(1)

    def invalid(self, *msg):
        if ( msg[0] != None ):
            print ' '.join(msg)

        print "For usage run"
        print "    start_ducc -h"
        print 'or'
        print '    start_ducc --help'
        sys.exit(1)
    
    def main(self, argv):

        environ = self.show_ducc_environment()
        for e in environ:
            print e

        if ( not self.verify_jvm() ):
            sys.exit(1);

        self.get_duccling_version();

        nodefiles = []
        components = []
        management = True
        single_user = False
        or_parms = self.ducc_properties.get('ducc.orchestrator.start.type')
        self.pids = DuccProperties()
        self.pids.load_if_exists(self.pid_file)
        
        try:
            opts, args = getopt.getopt(argv, 'c:mn:sh?v', ['component=', 'components=', 'help', 'nodelist=', 'management', 'singleuser', 'cold', 'warm', 'hot'])
        except:
            self.invalid('Invalid arguments', ' '.join(argv))
                       
        for ( o, a ) in opts:
            if o in ( '-c', '--components' ): 
                components.append(a)
            elif o in ( '-m', '--management' ):
                management = True
            elif o in ( '-n', '--nodelist' ):
                nodefiles.append(a)
            elif o in ( '-s', '--singleuser' ):
                single_user = True
            elif o in ( '--cold', '--warm', '--hot' ):
                or_parms = o[2:]         # (strip the leading --)
            elif ( o == '-v'):
                print self.version()
                sys.exit(0)
            elif o in ( '-h', '--help' ):
               self.usage(None)
            elif ( o == '-?'):
                self.usage(None)
            else:
                self.invalid('bad args: ', ' '.join(argv))

        # 'management' means start all the management daemons - if specific components are also specified
        # there is at least a redundancy and maybe also a conflict.
        if ( (len(components) != 0) and management ):
            self.invalid("The --management and --component options are mutually exclusive")

        # no args, or just -s - make equivalent of -management and -nodefile=DUCC.HOME/resources/ducc.nodes
        if ( (len(argv) == 0) or ((len(argv) == 1) and single_user) ):
            nodefiles =  self.default_nodefiles
            components = self.default_components
            must_verify_nodepools = True
        else:
            must_verify_nodepools = False

        # this means all the non-agent processes - conflicts are already checked
        if ( management ):
            components = self.default_components

        self.verify_required_directories()

        if ( 'or' in components ):
            self.check_orchestrator_lock()

        if ( not verify_master_node(self.ducc_properties) ):
            print 'FAIL: Cannot run javac to run java verification'
            return

        #print 'nodefiles:', nodefiles
        #print 'components:', components

        # make sure all the nodefiles exist and are readable
        ok = True
        nodes = {}
        for n in nodefiles:
            nodes = self.read_nodefile(n, nodes)

        for ( nf, nl ) in nodes.items():
            if ( nl == None ):
                print "Can't read nodefile", nf
                ok = False

        if ok and (len(nodefiles) > 0):
            if self.verify_class_configuration(nodes, must_verify_nodepools):
                print "OK: Class configuration checked"
            else:
                print "NOTOK: Bad configuration, cannot start."
                ok = False

        if ( not ok ):
            sys.exit(1)
                
        # activeMQ needs to be started externally before starting any DUCC processes
        if ( self.automanage and ('broker' in components) ):
            if ( self.is_amq_active() ):
                print 'ActiveMQ is already running on host and port:', self.broker_host + ':' + self.broker_port, 'NOT restarting'
            else:
                self.start_broker()

        if ( self.is_amq_active() ):
            print 'ActiveMQ is found on configured host and port:', self.broker_host + ':' + self.broker_port
        else:
            print 'ActiveMQ cannot be found on configured host and port:', self.broker_host + ':' + self.broker_port
            sys.exit(1)

        ducc = Ducc()

        for (nodefile, nodelist) in nodes.items():
            print '********** Starting agents from file', nodefile
            self.start_agents(nodelist, single_user)

        if ( len(components) != 0 ):
            print 'Starting', or_parms

            for com in components:
                if ( com == 'broker' ):
                    pass     # already started
                else:
                    self.start_component(ducc, com, or_parms, single_user)
        else:
            print 'Not starting management components.'

        if ( len(self.pids) > 0 ):
            self.pids.write(self.pid_file)
        return

if __name__ == "__main__":
    starter = StartDucc()
    starter.main(sys.argv[1:])
