#!/usr/bin/env python
# -----------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# -----------------------------------------------------------------------


import os
import sys
from time import time

from ducc_boot import *
set_ducc_home()


import getopt
import subprocess

from ducc_util import DuccUtil
from ducc_util  import DuccProperties
from local_hooks import verify_slave_node
from local_hooks import verify_master_node

class CheckDucc(DuccUtil):

    def validate(self, checkdate):
        verify_slave_node(checkdate, self.ducc_properties)
        self.check_clock_skew(checkdate)
        self.verify_jvm()
        return


    def verify_activemq(self):
        if ( self.is_amq_active() ):
            print 'ActiveMQ is found listening at', self.broker_protocol + "://" + self.broker_host + ':' + self.broker_port
            return True
        return False

    def usage(self, msg):
        if ( msg != None ):
            print msg
        print "Usage:"
        print "   check_ducc [options]"
        print "   If no options are given this is the equivalent of:"
        print ""
        print "      check_ducc -n ../resources/ducc.nodes"
        print ""
        print "Options:"
        print "    -n --nodelist nodefile"
        print "        Check for agents on the nodes in nodefile.  This option may be specified multiple time"
        print "        for multiple nodefiles.  The 'local' node is always checked"
        print ""
        print "    -u --user userid"
        print "        Userid is the user whose processes check_ducc searches for.  If not specified,"
        print "        the user executing check_ducc is used.  If specified as 'all' then all ducc processes"
        print "        are searched for."
        print ""
        print "    -k --kill"
        print "       Force-kill any DUCC process you find on a node (if normal stop_ducc isn't working.  This"
        print "       uses kill -9 and only kills processes owned by the invoking user."
        print "" 
        print "    -p --pids"
        print "       Rewrite the PID file. The PID file is always rewritten if any changes to processes are made.  Sometimes"
        print "       the PID file needs rebuilding.  This option causes the file to be rebuilt regardless of"
        print "       changes."
        print ""
        print "    -s localdate"
        print "       Validate the local installation, called via ssh usually. The date is the dat on the calling machine."
        print ""
        print "    -r --reap"
        print "       Reap user processes.  This uses kill -9 and ducc_ling to forcibly terrrminate user processes."
        print "       Only processes specified by '-u' or '--userid' are targeted."
        print ""
        print "    -? prints this message."
        sys.exit(1)
    
    def main(self, argv):

        self.show_ducc_environment()

        try:
            opts, args = getopt.getopt(argv, 'kn:prs:u:h?v')
        except:
            self.usage("Invalid arguments " + ' '.join(argv))
    
        nodefiles = []
        user = os.environ['LOGNAME']
        victim_user = None
        kill = False
        reap = False
        redo_pids = False
        process_changes = False
        do_validate = False
        checkdate = 0
        
        for ( o, a ) in opts:
            if ( o == '-n' ) :
                nodefiles.append(a)
            elif ( o == '-k' ) :
                kill = True
            elif ( o == '-u' ) :
                victim_user = a
            elif ( o == '-v'):
                ducc_util.version()
            elif ( o == '-r'):
                reap = True
            elif ( o == '-p'):
                redo_pids = True
            elif ( o == '-s'):
                # intended to be called recursively from check_ducc, NOT from the command line
                do_validate = True
                checkdate = float(a)
            elif ( o in ('-h', '-?') ):
                self.usage(None)
            elif ( o == '-v'):
                self.version(None)
            else:
                print 'badarg', a
                usage('bad arg: ' + a)               

        if ( do_validate ):
            # if validating, ONLY validate, called via ssh usually
            self.validate(checkdate)
            return

        if ( reap and (user == 'ducc') ):
            usage('Can only reap non-udcc users')

        jvm = self.ducc_properties.get('ducc.jvm')
        if ( jvm == None ):
            print 'WARN: ducc.jvm is not specified in ducc.properties. Default is simply "java" which may not work on all nodes.'

        if ( not verify_master_node(self.ducc_properties) ):
            print 'FAIL: Cannot verify master mode'
            return

        if ( not self.verify_activemq() ):
            print 'ActiveMQ is not running on', self.broker_protocol + "://" + self.broker_host + ':' + self.broker_port

        # init the PID file
        pids = DuccProperties()
        pids.load_if_exists(self.pid_file)

        # read the nodelists
        if ( len(nodefiles) == 0 ):
            nodefiles = self.default_nodefiles
        nodes = {}
        for nf in nodefiles:
            nodes = self.read_nodefile(nf, nodes)

        #
        # add in the local host if needed, and the webserver node
        #
        localnodes = []
        if ( not self.localhost in nodes ):
            localnodes.append(self.localhost)

        if ( not (self.webserver_node in ['localhost', self.localhost, None]) ):
            localnodes.append(self.webserver_node)

        if ( len(localnodes) > 0 ):
            nodes['local'] = localnodes

        # checking starts here        
        for (nodefile, nodelist) in nodes.items():
            if ( nodelist == None ):
                # loading the nodes prints the necessary message
                continue
            spacer = '   '            
            for node in nodelist:

                print 'Checking', node, '...',
                response = self.find_ducc_process(node)   # a tuple, (True|False, proclist)
                if ( not response[0] ):
                    continue
                proclist = response[1]              # a list of tuples, tuple is (component, pid, user)
                if ( len(proclist) > 0 ):
                    print ''
                    for proc in proclist:
                        component  = proc[0]
                        pid        = proc[1]
                        found_user = proc[2]
                        
                        if ( component == 'orchestrator' ):
                            component = 'or'
    
                        if ( (victim_user != None) and ( victim_user != found_user) ):
                            continue

                        process_id = found_user + ' ' + component + '@' + node + ' PID ' + pid 
                        if ( kill ) :
                            if ( user != found_user ):
                                print spacer, "Not killing someone else's process.", process_id
                            elif ( component == 'unknown-java' ):
                                print spacer, 'Not killing non-ducc process', process_id
                            else:
                                print spacer, 'Killing (kill -9)', process_id
                                self.kill_process(node, proc)
                                pids.delete(pid)
                                process_changes = True
                        elif ( reap ):
                            # reaping is only for non-ducc JD and JP processes, and only if ducc calls it
                            if ( user != 'ducc' ):
                                print "You're not ducc - reap is not allowed.", process_id
                            elif (found_user == 'ducc'):
                                print "Not reaping ducc process", process_id
                            elif ( component in ['jd', 'uima-as'] ):
                                print spacer, 'Reaping', process_id
                                self.ssh(node, False, '/local/ducc/bin/ducc_ling', '-u', found_user, '--', '/bin/kill', '-9', pid)
                            else:
                                print spacer, 'Not reaping unknown process', process_id
                        else:
                            print spacer, 'Found', process_id
                            full_name = component + '@' + node
                            if ( component == 'agent' ):
                                pids.put(full_name, pid)
    
                            if ( component in self.default_components ):
                                pids.put(full_name, pid)
                                pids.put(component, full_name)
                else:
                    print 'no processes found.'

                if ( not (kill or reap) ):                    
                    lines = self.ssh(node, True, self.DUCC_HOME + "/admin/check_ducc", "-s", str(int(time())))
                    while 1:
                        line = lines.readline()
                        if ( not line ):
                            break
                        line = line.strip()
                        print spacer, line
                        #print '[]', line

        if ( reap ):
            return

        if ( kill ):
            self.stop_broker()
            self.remove_orchestrator_lock()
                
        if ( len(pids) == 0):
            if ( os.path.exists(self.pid_file) ):
                os.remove(self.pid_file)
        elif (process_changes or redo_pids):
            pids.write(self.pid_file)

if __name__ == "__main__":
    checker = CheckDucc()
    checker.main(sys.argv[1:])
    
